<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Traveller Character Generator</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            margin: 0;
            color: #1e3c72;
            font-size: 2.5em;
        }
        
        .nav-buttons {
            margin-top: 15px;
        }
        
        .btn {
            background: #2a5298;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: #1e3c72;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn.secondary {
            background: #6c757d;
        }
        
        .btn.secondary:hover {
            background: #545b62;
        }
        
        .btn.danger {
            background: #dc3545;
        }
        
        .btn.danger:hover {
            background: #c82333;
        }
        
        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .card h2 {
            margin-top: 0;
            color: #1e3c72;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .character-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s;
        }
        
        .character-card:hover {
            transform: translateY(-5px);
        }
        
        .character-name {
            font-size: 1.5em;
            font-weight: bold;
            color: #1e3c72;
            margin-bottom: 10px;
        }
        
        .character-info {
            margin-bottom: 15px;
        }
        
        .character-info span {
            display: inline-block;
            margin-right: 15px;
            color: #666;
        }
        
        .character-info .upp {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #1e3c72;
            font-size: 1.1em;
        }
        
        .character-info .skills-display {
            color: #666;
            font-size: 0.9em;
        }
        
        .characteristics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .characteristic {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .characteristic strong {
            display: block;
            color: #1e3c72;
            font-size: 1.2em;
        }
        
        .skills {
            margin-top: 15px;
        }
        
        .skill-item {
            background: #e9ecef;
            padding: 5px 10px;
            border-radius: 3px;
            margin: 5px 5px 5px 0;
            display: inline-block;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #1e3c72;
        }
        
        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        .form-control:focus {
            outline: none;
            border-color: #2a5298;
        }
        
        select.form-control {
            cursor: pointer;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 18px;
            color: #666;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .mustering-results {
            background-color: #fff8dc;
            border: 2px solid #ffa500;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .mustering-results h6 {
            color: #b8860b;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .cash-rolls, .benefit-rolls {
            margin-bottom: 15px;
        }
        
        .cash-rolls ul, .benefit-rolls ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        
        .cash-rolls li, .benefit-rolls li {
            margin-bottom: 3px;
            font-family: "Courier New", monospace;
            color: #333;
        }
        
        .career-history {
            margin-top: 20px;
        }
        
        .career-event {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            border-left: 4px solid #2a5298;
        }
        
        .career-event strong {
            color: #1e3c72;
        }
        
        .generation-controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .generation-controls h3 {
            margin-top: 0;
            color: #1e3c72;
        }
        
        .mustering-benefits {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .benefit-item {
            padding: 10px;
            background: rgba(255, 165, 0, 0.1);
            border-radius: 5px;
            border-left: 3px solid #ffa500;
        }
        
        .benefit-item strong {
            color: #cc8400;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .characteristics {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .nav-buttons {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .btn {
                margin: 0;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="header">
                <h1>‚≠ê Classic Traveller Character Generator</h1>
                <div class="nav-buttons">
                    <button class="btn" @click="showPage('home')">Home</button>
                    <button class="btn" @click="showPage('characters')">Characters</button>
                    <button class="btn" @click="showPage('new-character')">New Character</button>
                </div>
            </div>
            
            <!-- Home Page -->
            <div v-if="currentPage === 'home'" class="card">
                <h2>Welcome to the Classic Traveller Character Generator</h2>
                <p>Generate characters for the Classic Traveller roleplaying game using the original rules and mechanics.</p>
                <p>Features:</p>
                <ul>
                    <li>Generate characteristics using 2D6 rolls</li>
                    <li>Enlist in various services (Navy, Marines, Army, Scouts, Merchants, Others)</li>
                    <li>Complete career progression with survival, commission, and promotion checks</li>
                    <li>Skill acquisition through career service</li>
                    <li>Reenlistment options to continue careers</li>
                    <li>Complete character record tracking</li>
                </ul>
                <div class="button-group">
                    <button class="btn" @click="showPage('characters')">View Characters</button>
                    <button class="btn" @click="showPage('new-character')">Create New Character</button>
                </div>
            </div>
            
            <!-- Characters List Page -->
            <div v-if="currentPage === 'characters'">
                <div class="card">
                    <h2>Character List</h2>
                    <button class="btn" @click="loadCharacters">Refresh List</button>
                    <button class="btn" @click="showPage('new-character')">Create New Character</button>
                </div>
                
                <div v-if="loading" class="loading">Loading characters...</div>
                <div v-if="error" class="error">[[ error ]]</div>
                
                <div v-if="!loading && characters.length === 0" class="card">
                    <p>No characters found. Create your first character!</p>
                    <button class="btn" @click="showPage('new-character')">Create Character</button>
                </div>
                
                <div v-if="!loading && characters.length > 0" class="character-grid">
                    <div v-for="character in characters" :key="character.character_id" class="character-card">
                        <div class="character-name">[[ character.name ]]</div>
                        <div class="character-info">
                            <span><strong>Age:</strong> [[ character.age ]]</span>
                            <span><strong>Terms:</strong> [[ character.terms_served ]]</span>
                            <span><strong>Career:</strong> [[ character.career || 'None' ]]</span>
                        </div>
                        <div class="button-group">
                            <button class="btn" @click="viewCharacter(character.character_id)">View</button>
                            <button class="btn danger" @click="deleteCharacter(character.character_id)">Delete</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- New Character Page -->
            <div v-if="currentPage === 'new-character'">
                <div class="card">
                    <h2>Create New Character</h2>
                    <div class="form-group">
                        <label for="seed">Seed (optional - for reproducible results):</label>
                        <input type="number" id="seed" v-model.number="newCharacter.seed" class="form-control" placeholder="Leave empty for random">
                    </div>
                    <button class="btn" @click="initializeCharacter" :disabled="loading">
                        [[ loading ? 'Creating...' : 'Initialize Character' ]]
                    </button>
                </div>
                
                <div v-if="error" class="error">[[ error ]]</div>
                <div v-if="success" class="success">[[ success ]]</div>
            </div>
            
            <!-- Character Detail Page -->
            <div v-if="currentPage === 'character-detail' && selectedCharacter">
                <div class="card">
                    <h2>[[ getDisplayName() ]]</h2>
                    <div class="character-info">
                        <span><strong>Age:</strong> [[ selectedCharacter.age ]]</span>
                        <span><strong>Terms:</strong> [[ formatTermsDisplay() ]]</span>
                        <span><strong>Career:</strong> [[ selectedCharacter.career || 'None' ]]</span>
                        <span v-if="selectedCharacter.rank !== undefined"><strong>Rank:</strong> [[ selectedCharacter.rank ]]</span>
                        <span v-if="hasAllCharacteristics()" class="upp"><strong>UPP:</strong> [[ generateUPP() ]]</span>
                        <span><strong>Seed:</strong> [[ selectedCharacter.seed ]]</span>
                    </div>
                    
                    <div v-if="hasSkills()" class="character-info">
                        <div class="skills-display">
                            <strong>Skills:</strong> [[ formatSkillsForDisplay() ]]
                        </div>
                    </div>
                    
                    <!-- Mustering Out Benefits -->
                    <div v-if="selectedCharacter.mustering_out_benefits" class="card" style="margin-top: 20px; background: #f0f8ff; border-left: 4px solid #ffa500;">
                        <h3>üéñÔ∏è Mustering Out Benefits</h3>
                        <div class="mustering-benefits">
                            <div v-if="selectedCharacter.mustering_out_benefits.cash" class="benefit-item">
                                <strong>üí∞ Cash:</strong> Cr[[ selectedCharacter.mustering_out_benefits.cash.toLocaleString() ]]
                            </div>
                            <div v-if="selectedCharacter.mustering_out_benefits.items && selectedCharacter.mustering_out_benefits.items.length > 0" class="benefit-item">
                                <strong>üéÅ Items:</strong> [[ selectedCharacter.mustering_out_benefits.items.join(', ') ]]
                            </div>
                            <div v-if="selectedCharacter.mustering_out_benefits.characteristic_boosts && Object.keys(selectedCharacter.mustering_out_benefits.characteristic_boosts).length > 0" class="benefit-item">
                                <strong>üìà Characteristic Boosts:</strong> 
                                <span v-for="(boost, char) in selectedCharacter.mustering_out_benefits.characteristic_boosts" :key="char">
                                    [[ char.charAt(0).toUpperCase() + char.slice(1) ]] +[[ boost ]]
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="button-group">
                        <button class="btn" @click="showPage('characters')">Back to List</button>
                        <button class="btn danger" @click="deleteCharacter(selectedCharacter.character_id || currentCharacterId)">Delete Character</button>
                    </div>
                </div>
                
                <!-- Characteristics Generation -->
                <div class="card" v-if="!hasAllCharacteristics()">
                    <h2>Characteristics</h2>
                    <div class="characteristics">
                        <div v-for="(value, name) in selectedCharacter.characteristics" :key="name" class="characteristic">
                            <strong>[[ value ]]</strong>
                            <span>[[ name.charAt(0).toUpperCase() + name.slice(1) ]]</span>
                        </div>
                    </div>
                    
                    <div class="button-group">
                        <button v-for="charName in missingCharacteristics()" 
                                :key="charName" 
                                class="btn" 
                                @click="generateCharacteristic(charName)"
                                :disabled="loading">
                            [[ loading ? 'Rolling...' : `Roll ${charName.charAt(0).toUpperCase() + charName.slice(1)}` ]]
                        </button>
                    </div>
                </div>
                
                <!-- Character Generation Controls -->
                <div class="generation-controls" v-if="hasAllCharacteristics()">
                    <h3>Character Generation</h3>
                    
                    <!-- Enlistment -->
                    <div v-if="!selectedCharacter.career">
                        <h4>Enlistment</h4>
                        <div class="form-group">
                            <label for="service">Choose Service:</label>
                            <select id="service" v-model="selectedService" class="form-control">
                                <option value="">Select a service</option>
                                <option v-for="service in availableServices" :key="service" :value="service">[[ service ]]</option>
                            </select>
                        </div>
                        <button class="btn" @click="attemptEnlistment" :disabled="!selectedService || loading">
                            [[ loading ? 'Enlisting...' : 'Attempt Enlistment' ]]
                        </button>
                    </div>
                    
                    <!-- Career Progression -->
                    <div v-if="selectedCharacter.career">
                        <h4>Career Progression</h4>
                        <div class="button-group">
                            <button class="btn" @click="checkSurvival" :disabled="loading" v-if="canAttemptSurvival()">
                                [[ loading ? 'Checking...' : 'Survival Check' ]]
                            </button>
                            <button class="btn" @click="checkCommission" :disabled="loading" v-if="canAttemptCommission()">
                                [[ loading ? 'Checking...' : 'Commission' ]]
                            </button>
                            <button class="btn" @click="checkPromotion" :disabled="loading" v-if="canAttemptPromotion()">
                                [[ loading ? 'Checking...' : 'Promotion' ]]
                            </button>
                        </div>
                        
                        <!-- Skill Resolution -->
                        <div v-if="canResolveSkills()">
                            <h5>Skill Resolution ([[ selectedCharacter.skill_eligibility ]] available)</h5>
                            <div class="form-group">
                                <label for="skillTable">Choose Skill Table:</label>
                                <select id="skillTable" v-model="selectedSkillTable" class="form-control">
                                    <option value="">Select a skill table</option>
                                    <option value="personal" v-if="getAvailableTables().personal">Personal</option>
                                    <option value="service" v-if="getAvailableTables().service">Service</option>
                                    <option value="advanced" v-if="getAvailableTables().advanced">Advanced</option>
                                    <option value="education" v-if="getAvailableTables().education">Education</option>
                                </select>
                            </div>
                            <button class="btn" @click="resolveSkill" :disabled="loading || !selectedSkillTable">
                                [[ loading ? 'Resolving...' : 'Resolve Skill' ]]
                            </button>
                        </div>
                        
                        <div v-if="needsReenlistmentDecision()" style="margin-top: 15px;">
                            <h5>End of Term Decision</h5>
                            <div class="form-group">
                                <div v-if="isCharacterInjured()">
                                    <label for="reenlistmentChoice">Medical Discharge Required:</label>
                                    <select id="reenlistmentChoice" v-model="selectedReenlistmentChoice" class="form-control">
                                        <option value="">Select to confirm</option>
                                        <option value="reenlist">Medical Discharge (injured - cannot continue)</option>
                                    </select>
                                    <small class="form-text text-muted">Your character was injured during the survival check and must be medically discharged.</small>
                                </div>
                                <div v-else>
                                    <label for="reenlistmentChoice">Choose your preference:</label>
                                    <select id="reenlistmentChoice" v-model="selectedReenlistmentChoice" class="form-control">
                                        <option value="">Select an option</option>
                                        <option value="reenlist">Reenlist (continue service)</option>
                                        <option value="leave" v-if="selectedCharacter.terms_served < 5">Leave (end service)</option>
                                        <option value="retire" v-if="selectedCharacter.terms_served >= 5">Retire (end service)</option>
                                    </select>
                                    <small class="form-text text-muted">
                                        <span v-if="selectedCharacter.terms_served < 5">After term 5, you must retire instead of leave.</span>
                                        <span v-if="selectedCharacter.terms_served >= 5">You can only retire after completing 5+ terms.</span>
                                        Rolling 12 means mandatory retention regardless of choice.
                                    </small>
                                </div>
                            </div>
                            <button class="btn" @click="attemptReenlistment" :disabled="loading || !selectedReenlistmentChoice">
                                [[ loading ? 'Processing...' : 'Submit Decision' ]]
                            </button>
                        </div>
                        
                        <!-- Mustering Out -->
                        <div v-if="musteringOutInfo" style="margin-top: 20px; padding: 15px; border: 2px solid #ffa500; border-radius: 5px; background-color: #fff8dc;">
                            <h5>üéñÔ∏è Mustering Out</h5>
                            <p>Your character has completed their military service and is eligible for mustering out benefits!</p>
                            <div class="mustering-info">
                                <p><strong>Career:</strong> [[ musteringOutInfo.career ]]</p>
                                <p><strong>Terms Served:</strong> [[ musteringOutInfo.terms_served ]]</p>
                                <p><strong>Rank:</strong> [[ musteringOutInfo.rank ]] [[ musteringOutInfo.rank_bonus > 0 ? '(+1 DM for rank 5+)' : '' ]]</p>
                                <p><strong>Total Mustering Out Rolls:</strong> [[ musteringOutInfo.total_rolls ]]</p>
                            </div>
                            
                            <div class="form-group">
                                <label for="cashRolls">Cash vs Benefits Allocation:</label>
                                <select id="cashRolls" v-model="selectedCashRolls" class="form-control">
                                    <option v-for="option in getCashRollOptions()" :key="option.value" :value="option.value">
                                        [[ option.label ]]
                                    </option>
                                </select>
                                <small class="form-text text-muted">You can take up to 3 rolls as cash, the rest must be benefits.</small>
                            </div>
                            
                            <div v-if="selectedCharacter.skills && selectedCharacter.skills.Gambling" class="form-group">
                                <p><strong>Gambling Skill:</strong> [[ selectedCharacter.skills.Gambling ]] (+[[ selectedCharacter.skills.Gambling ]] DM to cash rolls)</p>
                            </div>
                            
                            <button class="btn" @click="performMusteringOut" :disabled="loading || selectedCashRolls === null" style="background-color: #ffa500; color: white;">
                                [[ loading ? 'Processing...' : 'Muster Out' ]]
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Career History -->
                <div class="card" v-if="selectedCharacter.career_history && selectedCharacter.career_history.length > 0">
                    <h2>Career History</h2>
                    <div class="career-history">
                        <div v-for="(event, index) in selectedCharacter.career_history" :key="index" class="career-event">
                            <strong>[[ event.event_type.replace('_', ' ').toUpperCase() ]]</strong>
                            <div v-if="event.outcome">[[ event.outcome ]]</div>
                            <div v-if="event.skill_gained">Skill gained from [[ event.table_choice ]] table: [[ event.skill_gained ]]</div>
                            <div v-if="event.roll">Roll: [[ event.roll ]] (Target: [[ event.target ]])</div>
                        </div>
                    </div>
                </div>
                
                <div v-if="error" class="error">[[ error ]]</div>
                <div v-if="success" class="success" v-html="success"></div>
                <div style="background: yellow; padding: 10px; margin: 10px 0;">
                    <strong>DEBUG:</strong><br>
                    selectedCharacter exists: [[ !!selectedCharacter ]]<br>
                    selectedCharacter.career: [[ selectedCharacter?.career ]]<br>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;
        
        createApp({
            delimiters: ['[[', ']]'],
            
            data() {
                return {
                    currentPage: 'home',
                    characters: [],
                    selectedCharacter: null,
                    currentCharacterId: null,
                    availableServices: ['Navy', 'Marines', 'Army', 'Scouts', 'Merchants', 'Others'],
                    selectedService: '',
                    selectedSkillTable: '',
                    selectedReenlistmentChoice: '',
                    loading: false,
                    error: '',
                    success: '',
                    newCharacter: {
                        seed: null
                    },
                    commissionAttemptedThisTerm: false,
                    promotionAttemptedThisTerm: false,
                    survivalAttemptedThisTerm: false,
                    currentTermNumber: 0,
                    musteringOutInfo: null,
                    selectedCashRolls: null
                }
            },
            
            mounted() {
                // Check URL for routing
                const path = window.location.pathname;
                if (path === '/characters') {
                    this.showPage('characters');
                } else if (path === '/characters/new') {
                    this.showPage('new-character');
                } else if (path.startsWith('/characters/')) {
                    const characterId = path.split('/')[2];
                    this.viewCharacter(characterId);
                }
            },
            
            methods: {
                showPage(page) {
                    this.currentPage = page;
                    this.error = '';
                    this.success = '';
                    
                    // Update URL
                    const urls = {
                        'home': '/',
                        'characters': '/characters',
                        'new-character': '/characters/new',
                        'character-detail': `/characters/${this.currentCharacterId}`
                    };
                    
                    if (urls[page]) {
                        window.history.pushState(null, '', urls[page]);
                    }
                    
                    if (page === 'characters') {
                        this.loadCharacters();
                    }
                },
                
                async loadCharacters() {
                    this.loading = true;
                    this.error = '';
                    
                    try {
                        const response = await axios.get('/api/characters');
                        if (response.data.success) {
                            this.characters = response.data.characters;
                        } else {
                            this.error = response.data.error || 'Failed to load characters';
                        }
                    } catch (error) {
                        this.error = 'Failed to load characters: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async initializeCharacter() {
                    this.loading = true;
                    this.error = '';
                    this.success = '';
                    
                    try {
                        const data = {};
                        if (this.newCharacter.seed) {
                            data.seed = this.newCharacter.seed;
                        }
                        
                        const response = await axios.post('/api/character/initialize', data);
                        if (response.data.success) {
                            this.newCharacter.seed = null;
                            
                            // Navigate to character detail immediately
                            this.viewCharacter(response.data.character_id);
                        } else {
                            this.error = response.data.error || 'Failed to create character';
                        }
                    } catch (error) {
                        this.error = 'Failed to create character: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async viewCharacter(characterId) {
                    this.loading = true;
                    this.error = '';
                    this.currentCharacterId = characterId;
                    
                    try {
                        const response = await axios.get(`/api/character/${characterId}`);
                        if (response.data.success) {
                            this.selectedCharacter = response.data.character;
                            this.updateTermTracking();
                            this.showPage('character-detail');
                        } else {
                            this.error = response.data.error || 'Failed to load character';
                        }
                    } catch (error) {
                        this.error = 'Failed to load character: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async deleteCharacter(characterId) {
                    if (!confirm('Are you sure you want to delete this character?')) {
                        return;
                    }
                    
                    this.loading = true;
                    this.error = '';
                    
                    try {
                        const response = await axios.delete(`/api/character/${characterId}`);
                        if (response.data.success) {
                            this.success = 'Character deleted successfully!';
                            
                            // If we're on the character detail page, go back to characters list
                            if (this.currentPage === 'character-detail') {
                                setTimeout(() => {
                                    this.showPage('characters');
                                }, 1000);
                            } else {
                                // Refresh the characters list
                                this.loadCharacters();
                            }
                        } else {
                            this.error = response.data.error || 'Failed to delete character';
                        }
                    } catch (error) {
                        this.error = 'Failed to delete character: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                hasAllCharacteristics() {
                    if (!this.selectedCharacter || !this.selectedCharacter.characteristics) {
                        return false;
                    }
                    const required = ['strength', 'dexterity', 'endurance', 'intelligence', 'education', 'social'];
                    return required.every(char => this.selectedCharacter.characteristics.hasOwnProperty(char));
                },
                
                missingCharacteristics() {
                    if (!this.selectedCharacter || !this.selectedCharacter.characteristics) {
                        return ['strength', 'dexterity', 'endurance', 'intelligence', 'education', 'social'];
                    }
                    const required = ['strength', 'dexterity', 'endurance', 'intelligence', 'education', 'social'];
                    return required.filter(char => !this.selectedCharacter.characteristics.hasOwnProperty(char));
                },
                
                generateUPP() {
                    if (!this.hasAllCharacteristics()) {
                        return '';
                    }
                    
                    const chars = this.selectedCharacter.characteristics;
                    const hexValues = [
                        chars.strength,
                        chars.dexterity,
                        chars.endurance,
                        chars.intelligence,
                        chars.education,
                        chars.social
                    ].map(val => val > 9 ? String.fromCharCode(65 + val - 10) : val.toString());
                    
                    return hexValues.join('');
                },
                
                hasSkills() {
                    return this.selectedCharacter && 
                           this.selectedCharacter.skills && 
                           Object.keys(this.selectedCharacter.skills).length > 0;
                },
                
                getAvailableTables() {
                    if (!this.selectedCharacter || !this.selectedCharacter.career_history) {
                        return { personal: false, service: false, advanced: false, education: false };
                    }
                    
                    // Find the most recent skill resolution event to get available tables
                    const skillEvents = this.selectedCharacter.career_history.filter(event => 
                        event.event_type === 'skill_resolution' && event.available_tables
                    );
                    
                    if (skillEvents.length > 0) {
                        return skillEvents[skillEvents.length - 1].available_tables;
                    }
                    
                    // Default fallback (shouldn't happen if character has career history)
                    return { personal: true, service: true, advanced: true, education: false };
                },
                
                formatSkillsForDisplay() {
                    if (!this.hasSkills()) return '';
                    
                    return Object.entries(this.selectedCharacter.skills)
                        .map(([skill, level]) => `${skill}-${level}`)
                        .join(', ');
                },
                
                updateTermTracking() {
                    if (!this.selectedCharacter) return;
                    
                    // Reset tracking if we're in a new term OR if character just enlisted
                    const justEnlisted = this.selectedCharacter.career && 
                                       this.selectedCharacter.career_history && 
                                       this.selectedCharacter.career_history.length > 0 && 
                                       this.selectedCharacter.career_history[this.selectedCharacter.career_history.length - 1].event_type === 'enlistment_attempt';
                    
                    if (this.currentTermNumber !== this.selectedCharacter.terms_served || justEnlisted) {
                        this.currentTermNumber = this.selectedCharacter.terms_served;
                        this.commissionAttemptedThisTerm = false;
                        this.promotionAttemptedThisTerm = false;
                        this.survivalAttemptedThisTerm = false;
                    }
                    
                    // Check if commission, promotion, or survival was attempted THIS TERM
                    if (this.selectedCharacter.career_history) {
                        // Find events that happened after the start of current term
                        const currentTermStartIndex = this.findCurrentTermStartIndex();
                        const thisTermEvents = this.selectedCharacter.career_history.slice(currentTermStartIndex);
                        
                        if (thisTermEvents.some(event => event.event_type === 'commission_check')) {
                            this.commissionAttemptedThisTerm = true;
                        }
                        if (thisTermEvents.some(event => event.event_type === 'promotion_check')) {
                            this.promotionAttemptedThisTerm = true;
                        }
                        if (thisTermEvents.some(event => event.event_type === 'survival_check')) {
                            this.survivalAttemptedThisTerm = true;
                        }
                    }
                },

                findCurrentTermStartIndex() {
                    if (!this.selectedCharacter.career_history) return 0;
                    
                    const events = this.selectedCharacter.career_history;
                    
                    // Find the most recent reenlistment or enlistment that started current term
                    for (let i = events.length - 1; i >= 0; i--) {
                        const event = events[i];
                        if (event.event_type === 'survival_check') {
                            // Events after this survival check are in the new term
                            return i + 1;
                        }
                        if (event.event_type === 'reenlistment_attempt' && event.continue_career) {
                            // Events after successful reenlistment are in the new term
                            return i + 1;
                        }
                        if (event.event_type === 'enlistment_attempt') {
                            // Events after enlistment are in the first term
                            return i + 1;
                        }
                    }
                    
                    return 0;
                },
                
                canAttemptSurvival() {
                    return this.selectedCharacter && 
                           this.selectedCharacter.career &&
                           !this.survivalAttemptedThisTerm &&
                           this.needsSurvivalCheck();
                },
                
                needsSurvivalCheck() {
                    // Check if character needs survival check for current term
                    if (!this.selectedCharacter.career_history) return false;
                    
                    const events = this.selectedCharacter.career_history;
                    const lastEvent = events[events.length - 1];
                    
                    // Case 1: After any enlistment attempt (first term) - both enlisted and drafted need survival checks
                    if (lastEvent && lastEvent.event_type === 'enlistment_attempt') {
                        // Check if there's already a survival check after enlistment
                        const enlistmentIndex = events.length - 1;
                        for (let i = enlistmentIndex + 1; i < events.length; i++) {
                            if (events[i].event_type === 'survival_check') {
                                return false; // Already have survival check
                            }
                        }
                        return true; // Need survival check for first term
                    }
                    
                    // Case 2: After successful reenlistment (subsequent terms)
                    if (lastEvent && 
                        lastEvent.event_type === 'reenlistment_attempt' && 
                        lastEvent.continue_career) {
                        return !this.hasRecentSurvivalCheck();
                    }
                    
                    return false;
                },
                
                hasRecentSurvivalCheck() {
                    // Check if there's a survival check after the last reenlistment
                    if (!this.selectedCharacter.career_history) return false;
                    
                    const events = this.selectedCharacter.career_history;
                    let lastReenlistmentIndex = -1;
                    
                    for (let i = events.length - 1; i >= 0; i--) {
                        if (events[i].event_type === 'reenlistment_attempt' && events[i].continue_career) {
                            lastReenlistmentIndex = i;
                            break;
                        }
                    }
                    
                    if (lastReenlistmentIndex === -1) return false;
                    
                    // Check if there's a survival check after this reenlistment
                    for (let i = lastReenlistmentIndex + 1; i < events.length; i++) {
                        if (events[i].event_type === 'survival_check') {
                            return true;
                        }
                    }
                    
                    return false;
                },
                
                canAttemptCommission() {
                    return this.selectedCharacter && 
                           this.selectedCharacter.career &&
                           !this.selectedCharacter.commissioned &&
                           !this.commissionAttemptedThisTerm &&
                           this.survivalAttemptedThisTerm;
                },
                
                canAttemptPromotion() {
                    // Check if already promoted this term
                    if (this.selectedCharacter && this.selectedCharacter.terms && this.selectedCharacter.terms.length > 0) {
                        const currentTerm = this.selectedCharacter.terms[this.selectedCharacter.terms.length - 1];
                        if (currentTerm.promotions && currentTerm.promotions.length > 0) {
                            return false; // Already promoted this term
                        }
                    }
                    
                    return this.selectedCharacter && 
                           this.selectedCharacter.career &&
                           this.selectedCharacter.commissioned &&
                           !this.promotionAttemptedThisTerm &&
                           this.survivalAttemptedThisTerm;
                },
                
                canRetire() {
                    return this.selectedCharacter && 
                           this.selectedCharacter.terms_served >= 5;
                },
                
                isCharacterInjured() {
                    // Check if character was injured in the current term
                    if (!this.selectedCharacter || !this.selectedCharacter.terms) return false;
                    
                    // Get the most recent term
                    const currentTerm = this.selectedCharacter.terms[this.selectedCharacter.terms.length - 1];
                    return currentTerm && currentTerm.survival === "injured";
                },
                
                async generateCharacteristic(characteristicName) {
                    this.loading = true;
                    this.error = '';
                    
                    try {
                        const response = await axios.post(`/api/character/${this.currentCharacterId}/characteristic/${characteristicName}`);
                        if (response.data.success) {
                            // Reload character data
                            await this.viewCharacter(this.currentCharacterId);
                        } else {
                            this.error = response.data.error || `Failed to generate ${characteristicName}`;
                        }
                    } catch (error) {
                        this.error = `Failed to generate ${characteristicName}: ` + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async attemptEnlistment() {
                    this.loading = true;
                    this.error = '';
                    this.success = '';
                    
                    try {
                        const response = await axios.post(`/api/character/${this.currentCharacterId}/enlist`, {
                            service: this.selectedService
                        });
                        
                        if (response.data.success) {
                            this.success = `${response.data.outcome}! Assigned to ${response.data.assigned_service}`;
                            this.selectedService = '';
                            // Reload character data
                            await this.viewCharacter(this.currentCharacterId);
                        } else {
                            this.error = response.data.error || 'Enlistment failed';
                        }
                    } catch (error) {
                        this.error = 'Failed to process enlistment: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async checkSurvival() {
                    this.loading = true;
                    this.error = '';
                    this.success = '';
                    
                    try {
                        const response = await axios.post(`/api/character/${this.currentCharacterId}/survival`);
                        
                        if (response.data.success) {
                            this.survivalAttemptedThisTerm = true;
                            
                            if (response.data.survived) {
                                this.success = `Survived the term! Age: ${response.data.new_age}, Terms: ${response.data.new_terms_served}`;
                            } else {
                                this.success = `Survival check failed: ${response.data.outcome}`;
                            }
                            // Reload character data
                            await this.viewCharacter(this.currentCharacterId);
                        } else {
                            this.error = response.data.error || 'Survival check failed';
                        }
                    } catch (error) {
                        this.error = 'Failed to process survival: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async checkCommission() {
                    this.loading = true;
                    this.error = '';
                    this.success = '';
                    
                    try {
                        const response = await axios.post(`/api/character/${this.currentCharacterId}/commission`);
                        
                        if (response.data.success) {
                            this.commissionAttemptedThisTerm = true;
                            
                            if (response.data.commissioned) {
                                this.success = 'Successfully commissioned as an officer!';
                            } else {
                                this.success = 'Commission attempt failed, remaining enlisted.';
                            }
                            // Reload character data
                            await this.viewCharacter(this.currentCharacterId);
                        } else {
                            this.error = response.data.error || 'Commission check failed';
                        }
                    } catch (error) {
                        this.error = 'Failed to process commission: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async checkPromotion() {
                    this.loading = true;
                    this.error = '';
                    this.success = '';
                    
                    try {
                        const response = await axios.post(`/api/character/${this.currentCharacterId}/promotion`);
                        
                        if (response.data.success) {
                            this.promotionAttemptedThisTerm = true;
                            
                            if (response.data.promoted) {
                                this.success = `Successfully promoted to rank ${response.data.new_rank}!`;
                            } else {
                                this.success = 'Promotion attempt failed, rank unchanged.';
                            }
                            // Reload character data
                            await this.viewCharacter(this.currentCharacterId);
                        } else {
                            this.error = response.data.error || 'Promotion check failed';
                        }
                    } catch (error) {
                        this.error = 'Failed to process promotion: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async resolveSkill() {
                    this.loading = true;
                    this.error = '';
                    this.success = '';
                    
                    try {
                        const response = await axios.post(`/api/character/${this.currentCharacterId}/skill`, {
                            table_choice: this.selectedSkillTable
                        });
                        
                        if (response.data.success) {
                            const tableName = response.data.table_used.charAt(0).toUpperCase() + response.data.table_used.slice(1);
                            this.success = `Skill gained from ${tableName} table: ${response.data.skill_gained}`;
                            this.selectedSkillTable = '';
                            // Reload character data
                            await this.viewCharacter(this.currentCharacterId);
                        } else {
                            this.error = response.data.error || 'Skill resolution failed';
                        }
                    } catch (error) {
                        this.error = 'Failed to resolve skill: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async attemptReenlistment() {
                    this.loading = true;
                    this.error = '';
                    this.success = '';
                    
                    try {
                        const response = await axios.post(`/api/character/${this.currentCharacterId}/reenlist`, {
                            preference: this.selectedReenlistmentChoice
                        });
                        
                        if (response.data.success) {
                            this.success = `Decision result: ${response.data.outcome} (rolled ${response.data.roll} vs target ${response.data.target})`;
                            this.selectedReenlistmentChoice = '';
                            
                            // Reset term tracking for new term if continuing career
                            if (response.data.continue_career) {
                                this.commissionAttemptedThisTerm = false;
                                this.promotionAttemptedThisTerm = false;
                                this.survivalAttemptedThisTerm = false;
                            }
                            
                            // Handle mustering out if character failed re-enlistment
                            if (!response.data.continue_career && response.data.mustering_out_info) {
                                this.musteringOutInfo = response.data.mustering_out_info;
                                this.selectedCashRolls = this.musteringOutInfo.max_cash_rolls; // Default to max cash rolls
                                this.success += ` Character is eligible for mustering out with ${this.musteringOutInfo.total_rolls} rolls.`;
                            }
                            
                            // Reload character data
                            await this.viewCharacter(this.currentCharacterId);
                        } else {
                            this.error = response.data.error || 'Reenlistment failed';
                        }
                    } catch (error) {
                        this.error = 'Failed to process reenlistment: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                async performMusteringOut() {
                    this.loading = true;
                    this.error = '';
                    this.success = '';
                    
                    try {
                        const response = await axios.post(`/api/character/${this.currentCharacterId}/muster-out`, {
                            cash_rolls: this.selectedCashRolls
                        });
                        
                        if (response.data.success) {
                            const benefits = response.data.mustering_out_benefits;
                            let resultsHtml = '<div class="mustering-results"><h6>üéñÔ∏è Mustering Out Results</h6>';
                            
                            // Show cash roll details
                            if (benefits.cash_roll_details && benefits.cash_roll_details.length > 0) {
                                resultsHtml += '<div class="cash-rolls"><strong>Cash Rolls:</strong><ul>';
                                benefits.cash_roll_details.forEach(roll => {
                                    let rollText = `Roll ${roll.roll_number}: ${roll.base_roll}`;
                                    if (roll.rank_bonus > 0) rollText += ` +${roll.rank_bonus} (rank)`;
                                    if (roll.gambling_bonus > 0) rollText += ` +${roll.gambling_bonus} (gambling)`;
                                    rollText += ` = ${roll.total_roll} ‚Üí Cr${roll.amount.toLocaleString()}`;
                                    resultsHtml += `<li>${rollText}</li>`;
                                });
                                resultsHtml += `</ul><strong>Total Cash: Cr${benefits.cash.toLocaleString()}</strong></div>`;
                            }
                            
                            // Show benefit roll details
                            if (benefits.benefit_roll_details && benefits.benefit_roll_details.length > 0) {
                                resultsHtml += '<div class="benefit-rolls"><strong>Benefit Rolls:</strong><ul>';
                                benefits.benefit_roll_details.forEach(roll => {
                                    let rollText = `Roll ${roll.roll_number}: ${roll.base_roll}`;
                                    if (roll.rank_bonus > 0) rollText += ` +${roll.rank_bonus} (rank)`;
                                    rollText += ` = ${roll.total_roll} ‚Üí ${roll.benefit}`;
                                    resultsHtml += `<li>${rollText}</li>`;
                                });
                                resultsHtml += '</ul></div>';
                            }
                            
                            resultsHtml += '</div>';
                            this.success = resultsHtml;
                            
                            // Clear mustering out info
                            this.musteringOutInfo = null;
                            this.selectedCashRolls = null;
                            
                            // Reload character data
                            await this.viewCharacter(this.currentCharacterId);
                        } else {
                            this.error = response.data.error || 'Mustering out failed';
                        }
                    } catch (error) {
                        this.error = 'Failed to process mustering out: ' + error.message;
                    } finally {
                        this.loading = false;
                    }
                },
                
                getCashRollOptions() {
                    if (!this.musteringOutInfo) return [];
                    const options = [];
                    for (let i = 0; i <= Math.min(3, this.musteringOutInfo.total_rolls); i++) {
                        const benefitRolls = this.musteringOutInfo.total_rolls - i;
                        options.push({
                            value: i,
                            label: `${i} cash, ${benefitRolls} benefits`
                        });
                    }
                    return options;
                },

                getDisplayName() {
                    if (!this.selectedCharacter) return '';
                    
                    // Only add rank prefix for commissioned officers in services with ranks
                    if (this.selectedCharacter.commissioned && 
                        this.selectedCharacter.career && 
                        ['Navy', 'Marines', 'Army', 'Merchants'].includes(this.selectedCharacter.career)) {
                        
                        const rank = this.selectedCharacter.rank || 0;
                        const rankTitles = {
                            'Navy': ['Enlisted', 'Ensign', 'Lieutenant', 'Lt. Commander', 'Commander', 'Captain', 'Admiral'],
                            'Marines': ['Enlisted', 'Lieutenant', 'Captain', 'Major', 'Lt. Colonel', 'Colonel', 'General'],
                            'Army': ['Enlisted', 'Lieutenant', 'Captain', 'Major', 'Lt. Colonel', 'Colonel', 'General'],
                            'Merchants': ['Enlisted', '4th Officer', '3rd Officer', '2nd Officer', '1st Officer', 'Captain']
                        };
                        
                        const title = rankTitles[this.selectedCharacter.career][rank] || 'Officer';
                        return `${title} ${this.selectedCharacter.name}`;
                    }
                    
                    return this.selectedCharacter.name;
                },

                formatTermsDisplay() {
                    if (!this.selectedCharacter) return '';
                    
                    const termsServed = this.selectedCharacter.terms_served;
                    
                    // Check if character has a fractional term (0.5)
                    if (termsServed % 1 !== 0) {
                        // Character was separated mid-term, determine the reason
                        const separationReason = this.getSeparationReason();
                        const completedTerms = Math.floor(termsServed);
                        
                        if (completedTerms === 0) {
                            return `0 terms (${separationReason})`;
                        } else {
                            return `${completedTerms} terms (${separationReason})`;
                        }
                    }
                    
                    return termsServed.toString();
                },

                getSeparationReason() {
                    if (!this.selectedCharacter || !this.selectedCharacter.career_history) return 'separated';
                    
                    // Find the last reenlistment attempt
                    const events = this.selectedCharacter.career_history;
                    for (let i = events.length - 1; i >= 0; i--) {
                        const event = events[i];
                        if (event.event_type === 'reenlistment_attempt') {
                            if (event.outcome === 'medical_discharge') {
                                return 'medical discharge';
                            } else if (event.outcome === 'discharged') {
                                return this.selectedCharacter.terms_served >= 5 ? 'military discharge' : 'military discharge';
                            } else if (event.outcome === 'retired') {
                                return 'retired';
                            } else if (event.preference === 'discharge') {
                                return 'discharged';
                            } else if (event.preference === 'retire') {
                                return 'retired';
                            }
                            // If failed reenlistment roll
                            return 'military discharge';
                        }
                    }
                    
                    // Check if character was injured (for medical discharge)
                    for (let i = events.length - 1; i >= 0; i--) {
                        const event = events[i];
                        if (event.event_type === 'survival_check' && event.outcome === 'injured') {
                            return 'medical discharge';
                        }
                    }
                    
                    return 'separated';
                },

                canResolveSkills() {
                    // Skills can only be resolved after all required checks are completed
                    if (!this.selectedCharacter || !this.selectedCharacter.skill_eligibility || this.selectedCharacter.skill_eligibility === 0) {
                        return false;
                    }
                    
                    // Must have completed survival check first
                    if (!this.survivalAttemptedThisTerm) {
                        return false;
                    }
                    
                    // If character was injured, they can't do commission/promotion checks, so skills are available
                    if (this.isCharacterInjured()) {
                        return true;
                    }
                    
                    // For non-injured characters, check if commission and promotion checks are completed (if applicable)
                    return this.allRequiredChecksCompleted();
                },
                
                allRequiredChecksCompleted() {
                    // Check if all required commission and promotion checks are completed
                    const needsCommission = this.selectedCharacter && 
                                          this.selectedCharacter.career &&
                                          !this.selectedCharacter.commissioned &&
                                          ['Navy', 'Marines', 'Army', 'Merchants'].includes(this.selectedCharacter.career);
                    
                    const needsPromotion = this.selectedCharacter && 
                                         this.selectedCharacter.career &&
                                         this.selectedCharacter.commissioned &&
                                         ['Navy', 'Marines', 'Army', 'Merchants'].includes(this.selectedCharacter.career);
                    
                    // If commission is needed but not attempted, not ready for skills
                    if (needsCommission && !this.commissionAttemptedThisTerm) {
                        return false;
                    }
                    
                    // If promotion is needed but not attempted, not ready for skills
                    if (needsPromotion && !this.promotionAttemptedThisTerm) {
                        return false;
                    }
                    
                    return true;
                },

                needsReenlistmentDecision() {
                    // Character needs reenlistment decision if:
                    // 1. They have a career
                    // 2. They have completed survival check this term
                    // 3. Either they are injured (immediate medical discharge) OR all skills are resolved
                    if (!this.selectedCharacter || !this.selectedCharacter.career) {
                        return false;
                    }
                    
                    // Must have completed survival check
                    if (!this.survivalAttemptedThisTerm) {
                        return false;
                    }
                    
                    // If injured, immediate reenlistment decision (medical discharge)
                    if (this.isCharacterInjured()) {
                        return true;
                    }
                    
                    // For non-injured characters, reenlistment only appears when all skills are resolved
                    return this.selectedCharacter.skill_eligibility === 0;
                }
            }
        }).mount('#app');
    </script>
</body>
</html>